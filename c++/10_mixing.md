# Mixing

## Symbols

We have seen that symbols can have a different visibility wrt to others compilation units.

### `nm` bash command

With 

```bash
nm 01_hello.o # C compiled file
```

we can visualise the symbols present in a compiled file.

```bash
                 U _GLOBAL_OFFSET_TABLE_
0000000000000000 T main
                 U printf
```

`T` represent a text and `puts` is the variable generated by the `printf` function.
`U` is an undefined symbol that the linker has to find.

- lower case for the symbol represents internal linkage
- upper case for the symbol represents external linkage

### Differences between C and C++ in symbols

In a C++ code the `nm` message is more complicated, the main it's still present but any function called in a more complicated way.

```bash
nm 02_hello.o #C++ compiled file
```

Generate:

```bash
...
000000000000002f T main
000000000000003f t _Z41__static_initialization_and_destruction_0ii
0000000000000000 T _Z5hellov
...
```

`T _Z5hellov` is the `hello()` function. C++ allows function overloading by defining the symbol name for the function not only with the plain name of the function. The `v` at the end it's because the function is taking a `void` variable. At the beginning you have symbols for namespace and scope resolution. Note that the returned type is not part of the name and it's why it's not possible to have function overloading with only the returned type changed.

In the end the symbols generated by a C compiler are simpler and more important different from the one generated by a C++ compiler.

## Export keyword

The linker is not aware of the languages of what it's linking.

```c++
extern "C"{
  void hello(){
    std::cout << "Hello, World" << std::endl;
  }
}
```

The `export` keyword is used to ask to the compiler to export the symbol according to the language required. Compiling this code will generate the symbol for the `hello()` function according to C language.

```bash
ldd a.out
```

is a bash script that tells you which libraries are used by an executable.

## C form C++

I want to call a function from C in a C++ code.

I have to compile with the corresponding **compiler** the source file, while I have to use the **linker** of the language in which the main is written.

```bash
cc -c hello.c -o hello.o
c++ main.cpp -c -o main.o
c++ hello.o main.o -o exe
```

In the main when I have to use the function I have to include the header file of the C function, saying to the compiler to generate the file in the appropriate language for the linker.

Also in this case we want to use the `extern` keyword:

```c++
extern "C" {                                                             
#include "hello.h"
}
```

So the compiler will be able to see the signature of the function and the symbol will be generated according to C rules, so that the linker will see the C symbol, corresponding to the function in the C files.

```c++
extern "C"{
void hello_from_c();
}
```

If you need only a function you can put directly the signature of the function, without having to create an header file.

## C++ from C

In the C++ code I have to say:

```c++
extern "C" {
void hello_from_cpp() {
  std::cout << "hello from cpp\n";
}
}
```

The symbol generated for `hello_from_cpp()` is now compatible with C `T hello_from_cpp`.

In the C file you have to put the signature with the `extern` keyword:

```c
extern void hello_from_cpp(void);
```

The void in the arguments taken is to force a check on the arguments used in the invocations in the main, to see if they correspond to the required one. Defining it without the void is fine, but you can introduce bug with the function called with non appropriate arguments.

`src` -> `il` (intermediate language) -> `opt` (optimization) -> `as` (assembly) -> `.o` 
Only the first step is language dependent and it's why it's possible to mix different languages by linking the `.o` files. The different symbols are the initial signature of the language and with the `extern` keyword we can avoid the problem.

As a general rule don't mix compilers to generate the `.o` files because it should work but sometime the compilers have slightly different mangling for the symbol names.

In the linker you may have to include C++ libraries used by your C++ code, for example the standard library:

```bash
cc cpp2c.o main.o -lstdc++ -o exe
```

### Classes (C++ from C)

If I want to use a class I've to deal also with header files. We need to create an interface. In the main I can so call the functions created from the interface that will have to explicitly call the constructor, distructor and everything. The constructor will generate a pointer.

To make things clear I usually call `.hpp` the header files required by the C++ part of the code.

```c
typedef void* Foo_c;
```

In the header I have to put the prototypes for the functions required by the C code:

```c
#ifdef __cplusplus
extern "C" {
#endif

Foo_c create_foo(int b);
void free_foo(Foo_c);
void print_foo(Foo_c);
void set_a(Foo_c, int v);
int get_a(Foo_c);

#ifdef __cplusplus
}
#endif
```

But the functions defined in this header file have to be defined in a C++ file, because they will require C++ features.

```c++
#include "class_c_interface.h"
#include "class.hpp"

extern "C" {

Foo_c create_foo(int b) {
  return new Foo(b);
}
void free_foo(Foo_c f) {
  delete static_cast<Foo*>(f);
}
void print_foo(Foo_c f) {
  static_cast<Foo*>(f)->print();
}
void set_a(Foo_c f, int v) {
  static_cast<Foo*>(f)->get_a() = v;                                            
};
int get_a(Foo_c f) {
  return static_cast<Foo*>(f)->get_a();
}
}
```

You're only able to export non templated symbols. If you define a templated class you have to duplicate your C++ code by specifying the template used every time.

```c++
Foo_c create_foo(int b) {
  return new Foo<int>(b);      
}
```

## Ctypes (C to python)

In order to call functions written in C++ or C from python we need to pass in any case trough C, so we need only to understand only how to pass from  to python. Coming from C++ we need only to write a C interface as seen before.

```bash
cc -shared -fpic -o libhello.so hello.c -std=c11
```

We need to generate the C file as a shared library.

In the python file:

```python
from ctypes import * # to import the library used to import C code
dso = CDLL("./libhello.so") # import shared object on POSIX compatible OS
```

Where the `libhello.so` is the one created from the C code.

### No argument function

```python
dso.hello()
```

### String function

```python
dso.repeat.argtypes = [c_char_p]
dso.repeat.restype = c_int

res = dso.repeat(b"ctypes are great") # use b to pass read-only variable
```

You have to use `b` in front of the strings. In this case the string is read-only. If you need to modify it you need to use the `ctypes` library:

```python
buf = create_string_buffer(b"this could be modified") # mutable string
dso.repeat(buf)
```

### Array function

It's better in general to let python allocate (and deallocate) the array for you.

```python
size = 10
d_array = (c_double*size)() # construct a double array 
```

```python
array_sum.argtypes = [POINTER(c_double), c_size_t] 
array_sum.restype = c_double                                                    
print("the sum of d_array is", dso.array_sum(d_array,size))
```

### Structure

```python
class data(Structure):
    _fields_ = [("i",c_int),
                ("name",c_char_p),
                ("energy",c_double)] 
    # order is crucial otherwise seg-fault
```

Remember that in structures you can have only variables and not functions.

You define a list of tuples in order that has to be the same of the structure defined in the C file. At this point this is a normal class that can work with normal python functions.

To use on the structure a function:

```python
#dso.use_by_value.argtypes = [data] # redundant
dso.use_by_value(param)

dso.set_energy.argtypes = [POINTER(data), c_double]
dso.set_energy(param, 32.45)
```

To redefine elements of the structure:

```python
param.i=77
```

## Fortran from C++ (or C)

We want to use in C a sum function from Fortran code.

```bash
nm f-sum.o

0000000000000000 T sum_abs_ # a _ is appended to the function name
```

In Fortran everything is passed by reference. The function in C has to take into account the underscore in the name and this previous note. Remember also that the returned value is taken as initial argument by reference:

```c++
void sum_abs_(int *, int *, int *); // the last is the returned value
```

It's useful if you want to use ARCPAC library for mathematical work. Fortran doesn't have headers so you need to write by hand every signature of the functions that you want to use.